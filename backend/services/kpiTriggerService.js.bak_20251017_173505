const User = require('../models/User');
const KPIScore = require('../models/KPIScore');
const TrainingAssignment = require('../models/TrainingAssignment');
const AuditSchedule = require('../models/AuditSchedule');
const Notification = require('../models/Notification');
const EmailTemplateService = require('./emailTemplateService');

class KPITriggerService {
  constructor() {
    this.triggerRules = {
      // KPI Score based triggers
      scoreBased: {
        '85-100': {
          rating: 'Outstanding',
          training: null,
          audit: null,
          reward: true
        },
        '70-84': {
          rating: 'Excellent',
          training: null,
          audit: 'Audit Call'
        },
        '50-69': {
          rating: 'Satisfactory',
          training: null,
          audit: 'Audit Call + Cross-check last 3 months data'
        },
        '40-49': {
          rating: 'Need Improvement',
          training: 'Basic Training Module (Joining-level training)',
          audit: 'Audit Call + Cross-check last 3 months data + Dummy Audit Case'
        },
        'below-40': {
          rating: 'Unsatisfactory',
          training: 'Basic Training Module (Joining-level training)',
          audit: 'Audit Call + Cross-check last 3 months data + Dummy Audit Case',
          warning: true
        }
      }
    };
  }

  // Process KPI data from Excel and trigger actions (does NOT auto-create users)
  async processKPIFromExcel(excelData, period, submittedBy = null) {
    const results = [];
    const UnmatchedKPI = require('../models/UnmatchedKPI');
    const User = require('../models/User');

    for (const row of excelData) {
      try {
        const feName = row.FE;
        const feEmail = row['Email'] || '';
        const feEmployeeId = row['Employee ID'] || '';

        // Calculate KPI score up-front
        const kpiScore = await this.calculateKPIScore(row);
        const rating = this.getRating(kpiScore);

        // FIXED: Only search by Employee ID (completely unique identifier)
        const cleanEmployeeId = feEmployeeId ? String(feEmployeeId).trim() : '';
        
        console.log(`üîç Searching for Employee ID: "${cleanEmployeeId}"`);
        
        const matchedUser = cleanEmployeeId 
          ? await User.findOne({ employeeId: cleanEmployeeId })
          : null;
          
        if (matchedUser) {
          console.log(`‚úì Matched user by Employee ID: ${cleanEmployeeId} ‚Üí ${matchedUser.name}`);
        } else {
          console.log(`‚ùå No user found with Employee ID: ${cleanEmployeeId}`);
        }

        if (matchedUser) {
          // Normal flow for matched user: save KPI, process triggers, send emails to DB email
          const kpiRecord = await this.saveKPIScore(
            matchedUser._id,
            period,
            kpiScore,
            rating,
            row,
            submittedBy
          );

          const adminUser = submittedBy ? await User.findById(submittedBy) : null;
          const triggers = await this.processTriggers(matchedUser, kpiRecord, row, adminUser);

          results.push({
            fe: feName,
            matched: true,
            userId: matchedUser._id,
            employeeId: matchedUser.employeeId,
            email: matchedUser.email,
            kpiScore,
            rating,
            triggers,
            success: true
          });
        } else {
          // Unmatched: store and email to Excel email if present
          await UnmatchedKPI.findOneAndUpdate(
            {
              period,
              fe: cleanName || feName || 'Unknown',
              employeeId: cleanEmployeeId || undefined
            },
            {
              $set: {
                fe: cleanName || feName || 'Unknown',
                employeeId: cleanEmployeeId || undefined,
                email: cleanEmail || undefined,
            period,
            kpiScore,
            rating,
            rawData: row,
            createdBy: submittedBy || undefined
              }
            },
            { upsert: true, new: true, setDefaultsOnInsert: true }
          );

          // Prepare pseudo user for email content
          const pseudoUser = {
            _id: null,
            name: feName || 'Field Executive',
            email: feEmail || ''
          };
          const pseudoKPI = {
            overallScore: kpiScore,
            rating,
            period
          };

          let emailsSent = [];
          if (feEmail) {
            // Reuse email pipeline to send to the Excel email address
            const emailResult = await this.sendTemplatedEmail(
              'kpi',
              pseudoUser,
              pseudoKPI,
              { emailRecipients: { kpi: ['FE'] } },
              null,
              {}
            );
            emailsSent = emailResult?.results || [];
          }

          results.push({
            fe: feName,
            matched: false,
            employeeId: feEmployeeId || null,
            email: feEmail || null,
            kpiScore,
            rating,
            emailsSent,
            success: true
          });
        }
      } catch (error) {
        console.error(`Error processing KPI row for ${row.FE}:`, error);
        results.push({
          fe: row.FE,
          success: false,
          error: error.message
        });
      }
    }

    return results;
  }

  // Process individual KPI row
  async processKPIRow(row, period, submittedBy = null) {
    const fe = row.FE;
    
    console.log(`\nüìã Processing KPI for: ${fe}`);
    console.log(`   Employee ID: ${row['Employee ID'] || 'Not provided'}`);
    console.log(`   Email: ${row['Email'] || 'Not provided'}`);
    
    // Calculate KPI score (now async - uses database config)
    const kpiScore = await this.calculateKPIScore(row);
    const rating = this.getRating(kpiScore);
    
    console.log(`   KPI Score: ${kpiScore} | Rating: ${rating}`);
    
    // Find or create user (enhanced matching)
    const user = await this.findOrCreateUser(fe, row['Email'], row['Employee ID']);
    
    // Save KPI score
    const kpiRecord = await this.saveKPIScore(user._id, period, kpiScore, rating, row, submittedBy);
    
    // Get admin user for context
    const User = require('../models/User');
    const adminUser = submittedBy ? await User.findById(submittedBy) : null;
    
    // Process triggers (now fully dynamic)
    const triggers = await this.processTriggers(user, kpiRecord, row, adminUser);
    
    console.log(`   ‚úì Triggers processed: ${triggers.length} actions`);
    
    return {
      fe: fe,
      userId: user._id,
      employeeId: user.employeeId,
      email: user.email,
      kpiScore: kpiScore,
      rating: rating,
      triggers: triggers,
      success: true
    };
  }

  // Calculate KPI score from Excel row data - Using hardcoded logic
  async calculateKPIScore(row) {
    // Use fallback (hardcoded) calculation - no DB dependency
    return this.calculateKPIScoreFallback(row);
    
    /* OLD DB-based calculation (model not found)
    try {
      // Fetch active KPI configurations from database
      const KPIConfiguration = require('../models/KPIConfiguration');
      const configs = await KPIConfiguration.find({ isActive: true }).sort({ metric: 1 });
      
      if (!configs || configs.length === 0) {
        console.log('‚ö† No KPI configurations found, using fallback calculation');
        return this.calculateKPIScoreFallback(row);
      }

      // Parse Excel data
      const metrics = {
        'TAT': parseFloat(row['TAT %']) || 0,
        'Major Negativity': parseFloat(row['Major Negative %']) || 0,
        'Quality Concern': parseFloat(row['Quality Concern % Age']) || 0,
        'Neighbor Check': parseFloat(row['Neighbor Check % Age']) || 0,
        'Negativity': parseFloat(row['Negative %']) || 0,
        'App Usage': parseFloat(row['Online % Age']) || 0,
        'Insufficiency': parseFloat(row['Insuff %']) || 0
      };

      let totalScore = 0;

      // Calculate score for each metric using database configuration
      for (const config of configs) {
        const metricValue = metrics[config.metric] || 0;
        let metricScore = 0;

        // Find matching threshold
        for (const threshold of config.thresholds) {
          let conditionMet = false;
          
          switch (threshold.operator) {
            case '>=':
              conditionMet = metricValue >= threshold.value;
              break;
            case '>':
              conditionMet = metricValue > threshold.value;
              break;
            case '<=':
              conditionMet = metricValue <= threshold.value;
              break;
            case '<':
              conditionMet = metricValue < threshold.value;
              break;
            case '==':
            case '=':
              conditionMet = metricValue === threshold.value;
              break;
          }

          if (conditionMet) {
            metricScore = threshold.score;
            break; // Use first matching threshold
          }
        }

        totalScore += metricScore;
        console.log(`  ${config.metric}: ${metricValue}% ‚Üí Score: ${metricScore}`);
      }

      console.log(`üìä Total KPI Score (Dynamic): ${totalScore}`);
      return Math.round(totalScore * 100) / 100;

    } catch (error) {
      console.error('Error calculating KPI with database config:', error);
      console.log('Falling back to hardcoded calculation');
      return this.calculateKPIScoreFallback(row);
    }
    */
  }

  // Fallback calculation if database config fails
  calculateKPIScoreFallback(row) {
    const tatPercentage = parseFloat(row['TAT %']) || 0;
    const majorNegPercentage = parseFloat(row['Major Negative %']) || 0;
    const negPercentage = parseFloat(row['Negative %']) || 0;
    const qualityPercentage = parseFloat(row['Quality Concern % Age']) || 0;
    const insuffPercentage = parseFloat(row['Insuff %']) || 0;
    const neighborCheckPercentage = parseFloat(row['Neighbor Check % Age']) || 0;
    const onlinePercentage = parseFloat(row['Online % Age']) || 0;

    let tatScore = 0;
    if (tatPercentage >= 95) tatScore = 20;
    else if (tatPercentage >= 90) tatScore = 10;
    else if (tatPercentage >= 85) tatScore = 5;
    else tatScore = 0;

    let majorNegScore = 0;
    if (majorNegPercentage >= 2.5) majorNegScore = 20;
    else if (majorNegPercentage >= 2.0) majorNegScore = 15;
    else if (majorNegPercentage >= 1.5) majorNegScore = 5;
    else majorNegScore = 0;

    let qualityScore = 0;
    if (qualityPercentage === 0) qualityScore = 20;
    else if (qualityPercentage <= 0.25) qualityScore = 15;
    else if (qualityPercentage <= 0.5) qualityScore = 10;
    else qualityScore = 0;

    let neighborScore = 0;
    if (neighborCheckPercentage >= 90) neighborScore = 10;
    else if (neighborCheckPercentage >= 85) neighborScore = 5;
    else if (neighborCheckPercentage >= 80) neighborScore = 2;
    else neighborScore = 0;

    let negScore = 0;
    if (negPercentage >= 25) negScore = 10;
    else if (negPercentage >= 20) negScore = 5;
    else if (negPercentage >= 15) negScore = 2;
    else negScore = 0;

    let onlineScore = 0;
    if (onlinePercentage >= 90) onlineScore = 10;
    else if (onlinePercentage >= 85) onlineScore = 5;
    else if (onlinePercentage >= 80) onlineScore = 2;
    else onlineScore = 0;

    let insuffScore = 0;
    if (insuffPercentage < 1) insuffScore = 10;
    else if (insuffPercentage <= 1.5) insuffScore = 5;
    else if (insuffPercentage <= 2) insuffScore = 2;
    else insuffScore = 0;

    const overallScore = tatScore + majorNegScore + qualityScore + neighborScore + negScore + onlineScore + insuffScore;
    return Math.round(overallScore * 100) / 100;
  }

  // Get rating based on score
  getRating(score) {
    if (score >= 85) return 'Outstanding';
    if (score >= 70) return 'Excellent';
    if (score >= 50) return 'Satisfactory';
    if (score >= 40) return 'Need Improvement';
    return 'Unsatisfactory';
  }

  // FIXED: Find user ONLY by Employee ID (completely unique identifier)
async findOrCreateUser(feName, email = null, employeeId = null) {
  const cleanEmployeeId = employeeId ? employeeId.toString().trim() : null;
  
  if (!cleanEmployeeId) {
    console.log(`‚ùå No Employee ID provided for ${feName}`);
    return null;
  }
  
  console.log(`üîç Searching for Employee ID: "${cleanEmployeeId}"`);
  
  // Simple exact match by Employee ID
  const user = await User.findOne({ employeeId: cleanEmployeeId });
  
  if (user) {
    console.log(`‚úì Matched user by Employee ID: ${cleanEmployeeId} ‚Üí ${user.name}`);
  } else {
    console.log(`‚ùå No user found with Employee ID: ${cleanEmployeeId}`);
  }

  return user;
}

  // Save KPI score to database (UPDATE if exists, INSERT if new)
  async saveKPIScore(userId, period, score, rating, rawData, submittedBy = null) {
    const kpiData = {
      userId: userId,
      period: period,
      overallScore: score,
      rating: rating,
      // All required percentage fields
      tat: {
        percentage: parseFloat(rawData['TAT %']) || 0
      },
      majorNegativity: {
        percentage: parseFloat(rawData['Major Negative %']) || 0
      },
      quality: {
        percentage: parseFloat(rawData['Quality Concern % Age']) || 0
      },
      neighborCheck: {
        percentage: parseFloat(rawData['Neighbor Check % Age']) || 0
      },
      negativity: {
        percentage: parseFloat(rawData['Negative %']) || 0
      },
      appUsage: {
        percentage: parseFloat(rawData['Online % Age']) || 0
      },
      insufficiency: {
        percentage: parseFloat(rawData['Insuff %']) || 0
      },
      submittedBy: submittedBy,
      isActive: true
    };

    // Use findOneAndUpdate to UPDATE existing or CREATE new (upsert)
    const kpiScore = await KPIScore.findOneAndUpdate(
      { userId: userId, period: period }, // Find by userId + period
      { $set: kpiData }, // Update with new data
      { 
        upsert: true, // Create if doesn't exist
        new: true, // Return updated document
        setDefaultsOnInsert: true
      }
    );

    console.log(`   ${kpiScore.isNew ? '‚ú® Created' : 'üîÑ Updated'} KPI record for ${period}`);
    return kpiScore;
  }

  // Process all triggers for a user - ENHANCED with dynamic database configuration
  async processTriggers(user, kpiRecord, rawData, adminUser = null) {
    const triggers = [];

    // 1. Score-based triggers (now async - fetches from database)
    const scoreTriggers = await this.getScoreBasedTriggers(kpiRecord.overallScore);
    for (const trigger of scoreTriggers) {
      const result = await this.executeTrigger(user, kpiRecord, trigger, rawData, adminUser);
      triggers.push(result);
    }

    // 2. Condition-based triggers
    const conditionTriggers = await this.getConditionBasedTriggers(kpiRecord.overallScore, rawData);
    for (const trigger of conditionTriggers) {
      const result = await this.executeTrigger(user, kpiRecord, trigger, rawData, adminUser);
      triggers.push(result);
    }

    // 3. Create main KPI notification for user dashboard
    await this.createKPINotification(user, kpiRecord, triggers, adminUser);

    return triggers;
  }

  // Get condition-based triggers - Using fallback (no DB dependency)
  async getConditionBasedTriggers(overallScore, rawData) {
    // Use fallback directly - TriggerConfiguration model not available
    return this.getConditionBasedTriggersFallback(overallScore, rawData);
    
    /* OLD DB-based approach (model not found)
    try {
      const TriggerConfiguration = require('../models/TriggerConfiguration');
      const configs = await TriggerConfiguration.find({ 
        isActive: true,
        triggerType: 'condition_based'
      });

      const triggers = [];
      const majorNegPercentage = parseFloat(rawData['Major Negative %']) || 0;
      const negPercentage = parseFloat(rawData['Negative %']) || 0;
      const qualityPercentage = parseFloat(rawData['Quality Concern % Age']) || 0;
      const onlinePercentage = parseFloat(rawData['Online % Age']) || 0;
      const insuffPercentage = parseFloat(rawData['Insuff %']) || 0;

      // Process each database trigger
      for (const config of configs) {
        let conditionMet = false;
        
        // Parse and evaluate complex conditions
        const condition = config.condition;
        
        // Check various condition patterns
        if (condition.includes('Major Negativity') && condition.includes('General Negativity')) {
          conditionMet = majorNegPercentage > 0 && negPercentage < 25;
        } else if (condition.includes('Quality Concern')) {
          const thresholdMatch = condition.match(/>\s*(\d+\.?\d*)/);
          const thresholdValue = thresholdMatch ? parseFloat(thresholdMatch[1]) : config.threshold;
          conditionMet = qualityPercentage > thresholdValue;
        } else if (condition.includes('Insufficiency')) {
          const thresholdMatch = condition.match(/>\s*(\d+\.?\d*)/);
          const thresholdValue = thresholdMatch ? parseFloat(thresholdMatch[1]) : config.threshold;
          conditionMet = insuffPercentage > thresholdValue;
        } else if (condition.includes('Online % Age') || condition.includes('App Usage')) {
          const thresholdMatch = condition.match(/<\s*(\d+\.?\d*)/);
          const thresholdValue = thresholdMatch ? parseFloat(thresholdMatch[1]) : config.threshold;
          conditionMet = onlinePercentage < thresholdValue;
        }
        
        if (conditionMet && config.actions && config.actions.length > 0) {
          triggers.push({
            training: config.actions.find(a => a.includes('Training')) || null,
            audit: config.actions.find(a => a.includes('Audit')) || null,
            warning: config.actions.includes('Warning Letter'),
            conditionMet: condition,
            emailRecipients: {
              training: config.emailRecipients || [],
              audit: config.emailRecipients || [],
              warning: config.emailRecipients || []
            }
          });
        }
      }

      return triggers;

    } catch (error) {
      console.error('Error getting condition-based triggers:', error);
      return this.getConditionBasedTriggersFallback(overallScore, rawData);
    }
    */
  }

  // Fallback condition-based triggers
  getConditionBasedTriggersFallback(overallScore, rawData) {
    const triggers = [];
    const majorNegPercentage = parseFloat(rawData['Major Negative %']) || 0;
    const negPercentage = parseFloat(rawData['Negative %']) || 0;
    const qualityPercentage = parseFloat(rawData['Quality Concern % Age']) || 0;
    const onlinePercentage = parseFloat(rawData['Online % Age']) || 0;
    const insuffPercentage = parseFloat(rawData['Insuff %']) || 0;

    // Condition 1: Overall KPI Score < 55%
    if (overallScore < 55) {
      triggers.push({
        training: 'Basic Training Module (Joining-level training)',
        audit: 'Audit Call + Cross-check last 3 months data + Dummy Audit Case',
        conditionMet: 'Overall KPI Score < 55%',
        emailRecipients: {
          training: ['FE'], // Only send to FE
          audit: ['FE']
        }
      });
    }

    // Condition 2: Overall KPI Score < 40%
    if (overallScore < 40) {
      triggers.push({
        training: 'Basic Training Module (Joining-level training)',
        audit: 'Audit Call + Cross-check last 3 months data + Dummy Audit Case',
        warning: true,
        conditionMet: 'Overall KPI Score < 40%',
        emailRecipients: {
          training: ['FE'],
          audit: ['FE'],
          warning: ['FE']
        }
      });
    }

    // Condition 3: Major Negativity > 0% AND General Negativity < 25%
    if (majorNegPercentage > 0 && negPercentage < 25) {
      triggers.push({
        training: 'Negativity Handling Training Module',
        audit: 'Audit Call + Cross-check last 3 months',
        conditionMet: 'Major Negativity > 0% AND General Negativity < 25%',
        emailRecipients: {
          training: ['FE'],
          audit: ['FE']
        }
      });
    }

    // Condition 4: Quality Concern > 1%
    if (qualityPercentage > 1) {
      triggers.push({
        training: "Do's & Don'ts Training Module",
        audit: 'Audit Call + Cross-check last 3 months + RCA of complaints',
        conditionMet: 'Quality Concern > 1%',
        emailRecipients: {
          training: ['FE'],
          audit: ['FE']
        }
      });
    }

    // Condition 5: Cases Done on App < 80%
    if (onlinePercentage < 80) {
      triggers.push({
        training: 'Application Usage Training',
        audit: null,
        conditionMet: 'Cases Done on App < 80%',
        emailRecipients: {
          training: ['FE']
        }
      });
    }

    // Condition 6: Insufficiency > 2%
    if (insuffPercentage > 2) {
      triggers.push({
        training: null,
        audit: 'Cross-verification of selected insuff cases by another FE',
        conditionMet: 'Insufficiency > 2%',
        emailRecipients: {
          audit: ['FE']
        }
      });
    }

    return triggers;
  }

  // Get score-based triggers
  async getScoreBasedTriggers(score) {
    try {
      // Fetch active trigger configurations from database
      const TriggerConfiguration = require('../models/TriggerConfiguration');
      const configs = await TriggerConfiguration.find({ 
        isActive: true,
        triggerType: 'score_based'
      }).sort({ threshold: -1 }); // Sort descending to match highest threshold first
      
      if (!configs || configs.length === 0) {
        console.log('‚ö† No trigger configurations found, using fallback triggers');
        return this.getScoreBasedTriggersFallback(score);
      }

      const triggers = [];
      
      // Find matching triggers based on score
      for (const config of configs) {
        // Check if score meets the threshold condition
        const conditionMet = this.evaluateTriggerCondition(score, config.condition, config.threshold);
        
        if (conditionMet && config.actions && config.actions.length > 0) {
          triggers.push({
            training: config.actions.includes('Basic Training Module') ? 'Basic Training Module' : null,
            audit: config.actions.find(a => a.includes('Audit')) || null,
            warning: config.actions.includes('Warning Letter'),
            reward: config.actions.includes('Reward'),
            conditionMet: `${config.condition} ${config.threshold}`,
            emailRecipients: {
              training: config.emailRecipients || [],
              audit: config.emailRecipients || [],
              warning: config.emailRecipients || []
            }
          });
          break; // Use first matching trigger
        }
      }

      return triggers.length > 0 ? triggers : this.getScoreBasedTriggersFallback(score);

    } catch (error) {
      console.error('Error getting triggers from database:', error);
      return this.getScoreBasedTriggersFallback(score);
    }
  }

  // Evaluate trigger condition
  evaluateTriggerCondition(score, condition, threshold) {
    // Parse condition string like "Overall KPI Score < 70"
    if (condition.includes('<')) {
      return score < threshold;
    } else if (condition.includes('>')) {
      return score > threshold;
    } else if (condition.includes('<=')) {
      return score <= threshold;
    } else if (condition.includes('>=')) {
      return score >= threshold;
    }
    return false;
  }

  // Fallback triggers if database fetch fails
  getScoreBasedTriggersFallback(score) {
    const triggers = [];

    if (score >= 85) {
      triggers.push({
        ...this.triggerRules.scoreBased['85-100'],
        emailRecipients: {
          reward: ['FE'] // Only send to FE
        }
      });
    } else if (score >= 70) {
      triggers.push({
        ...this.triggerRules.scoreBased['70-84'],
        emailRecipients: {
          audit: ['FE'],
          kpi: ['FE']
        }
      });
    } else if (score >= 50) {
      triggers.push({
        ...this.triggerRules.scoreBased['50-69'],
        emailRecipients: {
          audit: ['FE'],
          kpi: ['FE']
        }
      });
    } else if (score >= 40) {
      triggers.push({
        ...this.triggerRules.scoreBased['40-49'],
        emailRecipients: {
          training: ['FE'],
          audit: ['FE']
        }
      });
    } else {
      triggers.push({
        ...this.triggerRules.scoreBased['below-40'],
        emailRecipients: {
          training: ['FE'],
          audit: ['FE'],
          warning: ['FE']
        }
      });
    }

    return triggers;
  }

  // Execute individual trigger - ENHANCED with email template service
  async executeTrigger(user, kpiRecord, trigger, rawData, adminUser) {
    const result = {
      type: trigger.training ? 'training' : trigger.audit ? 'audit' : trigger.reward ? 'reward' : 'warning',
      action: trigger.training || trigger.audit || (trigger.reward ? 'Reward Eligible' : 'Warning Letter'),
      executed: false,
      error: null,
      conditionMet: trigger.conditionMet || null,
      emailsSent: []
    };

    try {
      let trainingId = null;
      let auditId = null;

      // Create training assignment if needed
      if (trigger.training) {
        const training = await this.createTrainingAssignment(user, trigger.training, kpiRecord, trigger.conditionMet);
        trainingId = training._id;
        
        // Send email notifications using template service
        if (trigger.emailRecipients?.training) {
          const emailResult = await this.sendTemplatedEmail(
            'training',
            user,
            kpiRecord,
            trigger,
            adminUser,
            { trainingAssignmentId: training._id, trainingDetails: training }
          );
          result.emailsSent.push(...emailResult.results);
        }
        
        result.executed = true;
        result.trainingAssignmentId = training._id;
      }

      // Create audit schedule if needed
      if (trigger.audit) {
        const audit = await this.createAuditSchedule(user, trigger.audit, kpiRecord, trigger.conditionMet);
        auditId = audit._id;
        
        // Send email notifications using template service
        if (trigger.emailRecipients?.audit) {
          const emailResult = await this.sendTemplatedEmail(
            'audit',
            user,
            kpiRecord,
            trigger,
            adminUser,
            { auditScheduleId: audit._id, auditDetails: audit }
          );
          result.emailsSent.push(...emailResult.results);
        }
        
        result.executed = true;
        result.auditScheduleId = audit._id;
      }

      // Send reward notification if needed
      if (trigger.reward) {
        console.log(`üèÜ Reward trigger detected for ${user.name}`);
        console.log(`   Email recipients:`, trigger.emailRecipients);
        
        // Send email notifications using template service
        if (trigger.emailRecipients?.reward && trigger.emailRecipients.reward.length > 0) {
          console.log(`   Sending reward emails to:`, trigger.emailRecipients.reward);
          const emailResult = await this.sendTemplatedEmail(
            'reward',
            user,
            kpiRecord,
            trigger,
            adminUser,
            {}
          );
          console.log(`   Email result:`, emailResult);
          result.emailsSent.push(...emailResult.results);
        } else {
          console.log(`   ‚ö†Ô∏è No reward email recipients configured`);
        }
        
        result.executed = true;
      }

      // Send warning letter if needed
      if (trigger.warning) {
        // Send email notifications using template service
        if (trigger.emailRecipients?.warning) {
          const emailResult = await this.sendTemplatedEmail(
            'warning',
            user,
            kpiRecord,
            trigger,
            adminUser,
            {}
          );
          result.emailsSent.push(...emailResult.results);
        }
        
        result.executed = true;
      }

    } catch (error) {
      result.error = error.message;
      console.error('Error executing trigger:', error);
    }

    return result;
  }

  // Create main KPI notification for user dashboard
  async createKPINotification(user, kpiRecord, triggers, adminUser) {
    try {
      const Notification = require('../models/Notification');
      
      // Determine notification type and priority based on rating and triggers
      let notificationType = 'kpi';
      let priority = 'normal';
      let title = `KPI Score Update - ${kpiRecord.period}`;
      let message = `Your KPI score for ${kpiRecord.period} is ${kpiRecord.overallScore.toFixed(2)}% (${kpiRecord.rating}).`;

      // Check if there are any active triggers
      const activeTriggers = triggers.filter(t => t.executed);
      if (activeTriggers.length > 0) {
        priority = 'high';
        const triggerActions = activeTriggers.map(t => t.action).join(', ');
        message += ` Actions triggered: ${triggerActions}.`;
        
        // Set specific notification type based on triggers
        if (activeTriggers.some(t => t.type === 'training')) {
          notificationType = 'training';
          title = `Training Assignment - ${kpiRecord.period}`;
        } else if (activeTriggers.some(t => t.type === 'audit')) {
          notificationType = 'audit';
          title = `Audit Scheduled - ${kpiRecord.period}`;
        } else if (activeTriggers.some(t => t.type === 'warning')) {
          notificationType = 'performance';
          title = `Performance Warning - ${kpiRecord.period}`;
          priority = 'urgent';
        }
      }

      // Create notification
      await Notification.createNotification({
        userId: user._id,
        title: title,
        message: message,
        type: notificationType,
        priority: priority,
        sentBy: adminUser?._id || user._id,
        metadata: {
          kpiScore: kpiRecord.overallScore,
          rating: kpiRecord.rating,
          period: kpiRecord.period,
          kpiRecordId: kpiRecord._id,
          triggersExecuted: activeTriggers.length,
          actionRequired: activeTriggers.length > 0,
          actionUrl: activeTriggers.length > 0 ? '/notifications' : null
        }
      });

      console.log(`‚úÖ Created KPI notification for user ${user.name} (${user.email}) - ${notificationType} - ${priority}`);
      
    } catch (error) {
      console.error('Error creating KPI notification:', error);
    }
  }

  // Send templated emails using EmailTemplateService
  async sendTemplatedEmail(type, user, kpiRecord, trigger, adminUser, additionalData = {}) {
    try {
      console.log(`üìß Preparing email for type: ${type}`);
      console.log(`   User: ${user.name} (${user.email})`);
      console.log(`   Recipients: ${JSON.stringify(trigger.emailRecipients)}`);
      
      // USE NODEMAILER DIRECTLY (simpler, no service dependency)
      const nodemailer = require('nodemailer');
      
      const emailSubject = this.getEmailSubject(type, kpiRecord);
      const emailContent = this.getEmailContent(type, user, kpiRecord, trigger);
      
      const results = [];
      
      // Send to FE only (as per user requirement)
      if (user.email) {
        try {
          console.log(`   Sending to FE: ${user.email}`);
          
          // Create transporter (same as emailService)
          const transporter = nodemailer.createTransport({
            host: process.env.SMTP_HOST || 'smtp.gmail.com',
            port: parseInt(process.env.SMTP_PORT) || 587,
            secure: (process.env.SMTP_PORT || '587') === '465',
            auth: {
              user: process.env.SMTP_USER,
              pass: process.env.SMTP_PASS
            }
          });
          
          // Send email
          await transporter.sendMail({
            from: `"${process.env.FROM_NAME || 'E-Learning Platform'}" <${process.env.FROM_EMAIL || process.env.SMTP_USER}>`,
            to: user.email,
            subject: emailSubject,
            html: emailContent
          });
          
          results.push({
            to: user.email,
            status: 'sent',
            templateType: type
          });
          
          console.log(`   ‚úÖ Email sent successfully to ${user.email}`);
        } catch (emailError) {
          console.error(`   ‚ùå Email failed to ${user.email}:`, emailError.message);
          results.push({
            to: user.email,
            status: 'failed',
            error: emailError.message
          });
        }
      }
      
      return {
        success: results.length > 0,
        results: results
      };
      
    } catch (error) {
      console.error('‚ùå Send templated email error:', error);
      return {
        success: false,
        error: error.message,
        results: []
      };
    }
  }
  
  // Get email subject based on type
  getEmailSubject(type, kpiRecord) {
    switch (type) {
      case 'reward':
        return `üèÜ Congratulations! Outstanding KPI Performance - ${kpiRecord.period}`;
      case 'training':
        return `üìö Training Assignment - ${kpiRecord.period}`;
      case 'audit':
        return `üìã Audit Schedule - ${kpiRecord.period}`;
      case 'warning':
        return `‚ö†Ô∏è Performance Warning - ${kpiRecord.period}`;
      default:
        return `KPI Update - ${kpiRecord.period}`;
    }
  }
  
  // Get email content based on type
  getEmailContent(type, user, kpiRecord, trigger) {
    const commonHeader = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <h2>Dear ${user.name},</h2>
        <p>Your KPI score for <strong>${kpiRecord.period}</strong> is <strong>${kpiRecord.overallScore.toFixed(2)}%</strong> (${kpiRecord.rating})</p>
    `;
    
    const commonFooter = `
        <hr style="margin: 20px 0;">
        <p style="color: #666; font-size: 12px;">
          This is an automated email from E-Learning Platform. Please do not reply to this email.
        </p>
      </div>
    `;
    
    let content = '';
    
    switch (type) {
      case 'reward':
        content = `
          ${commonHeader}
          <div style="background-color: #d4edda; border: 1px solid #c3e6cb; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <h3 style="color: #155724; margin: 0;">üèÜ Outstanding Performance!</h3>
            <p style="color: #155724; margin: 10px 0 0 0;">
              Congratulations on your excellent performance! Keep up the great work!
            </p>
          </div>
          ${commonFooter}
        `;
        break;
        
      case 'training':
        content = `
          ${commonHeader}
          <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <h3 style="color: #856404;">üìö Training Assignment</h3>
            <p style="color: #856404;">
              <strong>Training Required:</strong> ${trigger.training || 'Basic Training Module'}<br>
              <strong>Reason:</strong> ${trigger.conditionMet || 'KPI improvement required'}<br>
              <strong>Due Date:</strong> ${new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toLocaleDateString()}
            </p>
          </div>
          ${commonFooter}
        `;
        break;
        
      case 'audit':
        content = `
          ${commonHeader}
          <div style="background-color: #d1ecf1; border: 1px solid #bee5eb; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <h3 style="color: #0c5460;">üìã Audit Schedule</h3>
            <p style="color: #0c5460;">
              <strong>Audit Type:</strong> ${trigger.audit || 'Performance Audit'}<br>
              <strong>Reason:</strong> ${trigger.conditionMet || 'Routine KPI check'}<br>
              <strong>Scheduled Date:</strong> ${new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toLocaleDateString()}
            </p>
          </div>
          ${commonFooter}
        `;
        break;
        
      case 'warning':
        content = `
          ${commonHeader}
          <div style="background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <h3 style="color: #721c24;">‚ö†Ô∏è Performance Warning</h3>
            <p style="color: #721c24;">
              Your performance requires immediate attention. Please improve in the following areas:<br><br>
              <strong>Concerns:</strong> ${trigger.conditionMet || 'Low KPI score'}<br>
              <strong>Action Required:</strong> Performance improvement plan
            </p>
          </div>
          ${commonFooter}
        `;
        break;
        
      default:
        content = `${commonHeader}${commonFooter}`;
    }
    
    return content;
  }
  
  // Note: Now using direct email service instead of template-based approach for simplicity

  // Create user notification
  async createUserNotification(user, type, action, kpiRecord) {
    const notification = new Notification({
      userId: user._id,
      type: type,
      title: `New ${type === 'training' ? 'Training' : 'Audit'} Assignment`,
      message: `You have been assigned: ${action}. KPI Score: ${kpiRecord.overallScore}% (${kpiRecord.rating})`,
      priority: 'high',
      isRead: false,
      metadata: {
        kpiScoreId: kpiRecord._id,
        period: kpiRecord.period,
        score: kpiRecord.overallScore,
        rating: kpiRecord.rating
      }
    });

    await notification.save();
    return notification;
  }

  // Send training notifications via email
  async sendTrainingNotifications(user, training, kpiRecord, recipients) {
    const emailData = {
      fe: user.name,
      feEmail: user.email,
      trainingType: training.trainingType,
      kpiScore: kpiRecord.overallScore,
      rating: kpiRecord.rating,
      period: kpiRecord.period,
      dueDate: training.dueDate.toLocaleDateString()
    };

    // Send to specified recipients
    if (recipients.includes('FE')) {
      console.log(`[EMAIL] Training notification sent to FE: ${user.email}`);
    }
    if (recipients.includes('Coordinator')) {
      console.log(`[EMAIL] Training notification sent to Coordinator for FE: ${user.name}`);
    }
    if (recipients.includes('Manager')) {
      console.log(`[EMAIL] Training notification sent to Manager for FE: ${user.name}`);
    }
    if (recipients.includes('HOD')) {
      console.log(`[EMAIL] Training notification sent to HOD for FE: ${user.name}`);
    }
    if (recipients.includes('Compliance Team')) {
      console.log(`[EMAIL] Training notification sent to Compliance Team for FE: ${user.name}`);
    }

    // TODO: Implement actual email sending using emailService
    // await emailService.sendTrainingAssignmentEmail(emailData, recipients);
  }

  // Send audit notifications via email
  async sendAuditNotifications(user, audit, kpiRecord, recipients) {
    const emailData = {
      fe: user.name,
      feEmail: user.email,
      auditType: audit.auditType,
      kpiScore: kpiRecord.overallScore,
      rating: kpiRecord.rating,
      period: kpiRecord.period,
      scheduledDate: audit.scheduledDate.toLocaleDateString()
    };

    // Send to specified recipients
    if (recipients.includes('Compliance Team')) {
      console.log(`[EMAIL] Audit notification sent to Compliance Team for FE: ${user.name}`);
    }
    if (recipients.includes('HOD')) {
      console.log(`[EMAIL] Audit notification sent to HOD for FE: ${user.name}`);
    }

    // TODO: Implement actual email sending using emailService
    // await emailService.sendAuditScheduleEmail(emailData, recipients);
  }

  // Send warning notifications via email
  async sendWarningNotifications(user, kpiRecord, recipients) {
    const emailData = {
      fe: user.name,
      feEmail: user.email,
      kpiScore: kpiRecord.overallScore,
      rating: kpiRecord.rating,
      period: kpiRecord.period,
      warningReason: `Performance below acceptable standards (${kpiRecord.overallScore}%)`
    };

    // Send to specified recipients
    for (const recipient of recipients) {
      console.log(`[EMAIL] Warning letter sent to ${recipient} for FE: ${user.name}`);
    }

    // TODO: Implement actual email sending using emailService
    // await emailService.sendWarningLetterEmail(emailData, recipients);
  }

  // Create training assignment - ENHANCED with condition tracking
  async createTrainingAssignment(user, trainingType, kpiRecord, conditionMet = null) {
    // Map training type to valid enum values
    let validTrainingType = 'basic';
    
    if (trainingType.toLowerCase().includes('negativity')) {
      validTrainingType = 'negativity_handling';
    } else if (trainingType.toLowerCase().includes("don't") || trainingType.toLowerCase().includes('dos')) {
      validTrainingType = 'dos_donts';
    } else if (trainingType.toLowerCase().includes('app') || trainingType.toLowerCase().includes('usage')) {
      validTrainingType = 'app_usage';
    }
    
    console.log(`   üìö Mapping training: "${trainingType}" ‚Üí "${validTrainingType}"`);
    
    const trainingAssignment = new TrainingAssignment({
      userId: user._id,
      trainingType: validTrainingType,
      assignedBy: 'system',
      assignedAt: new Date(),
      dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days from now
      status: 'assigned',
      priority: 'high',
      reason: conditionMet || `KPI Score: ${kpiRecord.overallScore}% (${kpiRecord.rating})`,
      notes: `Automatically assigned based on KPI performance for period ${kpiRecord.period}. Original: ${trainingType}`
    });

    await trainingAssignment.save();
    console.log(`   ‚úÖ Training assignment created: ${validTrainingType}`);
    return trainingAssignment;
  }

  // Create audit schedule - ENHANCED with condition tracking
  async createAuditSchedule(user, auditType, kpiRecord, conditionMet = null) {
    // Map audit type to valid enum values
    let validAuditType = 'audit_call';
    
    if (auditType.toLowerCase().includes('cross-check') || auditType.toLowerCase().includes('cross-verification')) {
      validAuditType = 'cross_check';
    } else if (auditType.toLowerCase().includes('dummy')) {
      validAuditType = 'dummy_audit';
    }
    
    console.log(`   üìã Mapping audit: "${auditType}" ‚Üí "${validAuditType}"`);
    
    const auditSchedule = new AuditSchedule({
      userId: user._id,
      auditType: validAuditType,
      scheduledBy: 'system',
      scheduledAt: new Date(),
      scheduledDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000), // 3 days from now
      status: 'scheduled',
      priority: 'high',
      reason: conditionMet || `KPI Score: ${kpiRecord.overallScore}% (${kpiRecord.rating})`,
      notes: `Automatically scheduled based on KPI performance for period ${kpiRecord.period}. Original: ${auditType}`
    });

    await auditSchedule.save();
    console.log(`   ‚úÖ Audit schedule created: ${validAuditType}`);
    return auditSchedule;
  }

  // Send warning letter
  async sendWarningLetter(user, kpiRecord) {
    const notification = new Notification({
      userId: user._id,
      type: 'warning',
      title: 'Performance Warning Letter',
      message: `Your KPI score of ${kpiRecord.overallScore}% (${kpiRecord.rating}) requires immediate attention. Please improve your performance to meet company standards.`,
      priority: 'high',
      isRead: false
    });

    await notification.save();
    return notification;
  }

  // Get all pending triggers
  async getPendingTriggers() {
    const pendingTraining = await TrainingAssignment.find({ status: 'assigned' })
      .populate('userId', 'name email')
      .sort({ assignedAt: -1 });

    const pendingAudits = await AuditSchedule.find({ status: 'scheduled' })
      .populate('userId', 'name email')
      .sort({ scheduledAt: -1 });

    return {
      training: pendingTraining,
      audits: pendingAudits
    };
  }

  // Get trigger history for a user
  async getTriggerHistory(userId, limit = 10) {
    const trainingAssignments = await TrainingAssignment.find({ userId })
      .sort({ assignedAt: -1 })
      .limit(limit);

    const auditSchedules = await AuditSchedule.find({ userId })
      .sort({ scheduledAt: -1 })
      .limit(limit);

    return {
      training: trainingAssignments,
      audits: auditSchedules
    };
  }
}

module.exports = new KPITriggerService();